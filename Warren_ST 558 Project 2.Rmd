---
title: "Using the Fed Treasury API as an Example of Interacting with APIs"
author: "Eric Warren"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

This document is a vignette to show how to get data from an [API](https://aws.amazon.com/what-is/api/). To demonstrate, I'll be interacting with the [Fed Treasury API](https://fiscaldata.treasury.gov/api-documentation/), which include the the [Fed Treasury API on Interest Rates](https://fiscaldata.treasury.gov/datasets/average-interest-rates-treasury-securities/average-interest-rates-on-u-s-treasury-securities), the [Fed Treasury API on Balance Sheets](https://fiscaldata.treasury.gov/datasets/u-s-government-financial-report/balance-sheets), and the [Fed Treasury API on National Debt](https://fiscaldata.treasury.gov/datasets/debt-to-the-penny/debt-to-the-penny). There will be a few functions built to interact with some of the endpoints and then will be followed up by some exploratory data analysis with some of the data that is retrieved from the API.

# Initial Requirements

To use the functions for interacting with the Fed Treasury API, I used the following packages:

- [`tidyverse`](https://www.tidyverse.org/): There are many useful features for data manipulation and visualization within the group of packages associated with the `tidyverse` universe.
- [`jsonlite`](https://cran.r-project.org/web/packages/jsonlite/): Allows API interaction to get the necessary data we are going to use in this document.
- [`httr`](https://cran.r-project.org/web/packages/httr/index.html): Allows us to get our data from the desired URL.

```{r load libraries needed, echo=FALSE}
# Load in the packages.
library(tidyverse)
library(jsonlite)
library(httr)
```

# API Interaction Functions

Here is where I am going to make some functions that will help with fulfilling our needs with reading in and analyzing our data from the [Fed Treasury API](https://fiscaldata.treasury.gov/api-documentation/), which include the the [Fed Treasury API on Interest Rates](https://fiscaldata.treasury.gov/datasets/average-interest-rates-treasury-securities/average-interest-rates-on-u-s-treasury-securities), the [Fed Treasury API on Balance Sheets](https://fiscaldata.treasury.gov/datasets/u-s-government-financial-report/balance-sheets), and the [Fed Treasury API on National Debt](https://fiscaldata.treasury.gov/datasets/debt-to-the-penny/debt-to-the-penny).

## `removeNulls()`

Once you do read in your data set immediately use this function to remove null values since they will not help in our analysis since we need to know all the information in the columns to get any kind of result. We should filter our data frame or tibble to what we want with the appropriate columns before using this function.
```{r remove nulls}
removeNulls <- function(df_name){
  # Copy df_name
  df <- df_name
  
  # Get null values and get rid of observations that have them and columns that are mostly null (over 50%)
  df <- df[ , colMeans(!(df == "null")) > 0.5] # Columns first
  df$countNulls <- apply(df, 1, function(x) length(which(x == "null"))) # Now rows
  df <- df[df$countNulls == 0, ]
  df <- df[1:length(df)-1]
  
  # Return updated df
  return(df)
}
```

## `convertToCorrectType()`

This function was made since the data in our API was returning dates in the character format. We needed a way to have the dates accurately show up in our data set. We had the same issue with our numeric data. So we created a function that allows the vector (or a column in our dataset) to end up in the correct type of data (either numeric, date, or character). Please use the function `removeNulls()` first to make sure our data does not have missing values which will not help us in our analyzing. 
```{r character to dates}
convertToCorrectType <- function(x){
  # Make conditional statement to make sure column can be date
  correctOutput <- if(all(is.na(suppressWarnings(as.Date(x, format = "%Y-%m-%d"))) == FALSE)) as.Date(x, format = "%Y-%m-%d") else if(all(is.na(suppressWarnings(as.numeric(x))) == FALSE)) as.numeric(x) else x
  return(correctOutput)
}
```

## `getSecurityList()`

This function acts as a helper function for the user as we can now get the list of Security Type Descriptions for the [Fed Treasury API on Interest Rates](https://fiscaldata.treasury.gov/datasets/average-interest-rates-treasury-securities/average-interest-rates-on-u-s-treasury-securities) (so if we want to look at Marketable, Non-marketable, or Interest-bearing Debt specific type securities) or if we want to subset even further later on, we can get the exact security names that are available (example: "Treasury Bills", "Treasury Notes", etc.)
```{r security names function}
getSecurityList <- function(x = "security type"){
  # Get the data in the correct format to get the list of unique values; limit is 4500 which includes all data
  jsonData <- httr::GET("https://api.fiscaldata.treasury.gov/services/api/fiscal_service/v2/accounting/od/avg_interest_rates?limit=9999")
  contents <- jsonlite::fromJSON(rawToChar(jsonData$content))
  tibble <- as_tibble(contents$data)
  
  # Now get the list of values depending on value inputted; default is "security type"
  outputList <- if(x == "security type") unique(tibble$security_type_desc) else if(x == "specific securities") unique(tibble$security_desc) else stop("Input must be either 'security type' to get the security type options or 'specific securities' to get the exact security names (individual options -- like Treasury Bills, Treasury Notes, etc.) The default is 'security type'.")
  
  return(outputList)
}
```

## `getAccountTypes()`

This function acts as a helper function for the user as we can now get the list of Account Type Descriptions for the [Fed Treasury API on Balance Sheets](https://fiscaldata.treasury.gov/datasets/u-s-government-financial-report/balance-sheets) (so if we want to look at Assets, Liabilities, etc.) or if we want to subset even further later on, we can get the exact line item names that are available (example: "Accounts payable", "Interest payable", etc.)
```{r security names function}
getAccountTypes <- function(x = "account"){
  # Get the data in the correct format to get the list of unique values; limit is 4500 which includes all data
  jsonData <- httr::GET("https://api.fiscaldata.treasury.gov/services/api/fiscal_service/v2/accounting/od/balance_sheets?limit=9999")
  contents <- jsonlite::fromJSON(rawToChar(jsonData$content))
  tibble <- as_tibble(contents$data)
  
  # Now get the list of values depending on value inputted; default is "security type"
  outputList <- if(x == "account") unique(tibble$account_desc) else if(x == "line items") unique(tibble$line_item_desc) else stop("Input must be either 'account' to get the account type options or 'line items' to get the exact line item names (individual options -- like Accounts payable, Total assets, etc.) The default is 'account'.")
  
  return(outputList)
}
```

## `getUnfilteredData()`

Here we can just get a data set by using this function and specifying which full data set we want from the corresponding API. We might not want to filter anything but if we do then we can do that in later functions.
```{r get data}
getUnfilteredData <- function(data = "interest rates"){
  # Get text set up
  jsonString <- "https://api.fiscaldata.treasury.gov/services/api/fiscal_service/v2/accounting/od/"
  endpoint1 <- "avg_interest_rates"
  endpoint2 <- "debt_to_penny"
  endpoint3 <- "balance_sheets"
  usedEndpoint <- if(data == "interest rates") endpoint1 else if(data == "debt") endpoint2 else if (data == "balance sheet") endpoint3 else stop("The data operator must either be 'interest rates' to get the Interest Rate API, 'balance sheet' to get the Balance Sheet API, or 'debt' to get data from the National Debt API. The default if left blank is the 'interest rates' argument.")
  limitText <- "?limit=9999"
  
  
  # Get the url
  finalString <- paste(jsonString, usedEndpoint, limitText, sep = "")
  
  # Convert to tibble
  jsonData <- httr::GET(finalString)
  
  contents <- jsonlite::fromJSON(rawToChar(jsonData$content))
  
  tibble <- as_tibble(contents$data)
  
  # Return tibble
  return(tibble)
}
```

Now we are going to start looking at functions we can make by filtering the data and make our API more interactive for the user.

## `filterDate()`

As an investor, we might pick a certain security or a group of them because we are told to look at them or we feel more confident in them. Other times people might want to pick how well securities are doing in recent time. What if we wanted to instead look at the balance sheet? Or what about the US Debt? And what if we want to look at either of these metrics over a certain period of time? That is why we are creating this function so the user can filter by the date they would like. Please note the dates must be in a "yyyy-mm-dd" format. Also please specify your arguments. This function is very similar to `getUnfilteredData()` except now we are specifying the date range we want along with the data set in question.
```{r filter date function}
filterDate <- function(data = "interest rates", date = NULL, operator = NULL){
  # Get text set up
  jsonString <- "https://api.fiscaldata.treasury.gov/services/api/fiscal_service/v2/accounting/od/"
  endpoint1 <- "avg_interest_rates"
  endpoint2 <- "debt_to_penny"
  endpoint3 <- "balance_sheets"
  usedEndpoint <- if(data == "interest rates") endpoint1 else if(data == "debt") endpoint2 else if (data == "balance sheet") endpoint3 else stop("The data operator must either be 'interest rates' to get the Interest Rate API, 'balance sheet' to get the Balance Sheet API, or 'debt' to get data from the National Debt API. The default if left blank is the 'interest rates' argument.")
  limitFilterText <- "?limit=9999&filter="
  
  # Get the correct text for the data we want.
  addedText <- if ((is.null(operator) == TRUE) | (is.null(date) == TRUE)) "" else if(operator %in% c("lt", "gt", "lte", "gte", "eq")) paste("record_date:", operator, ":", URLencode(date), ",", sep = "") else stop("Please input a value that is acceptable. The date option must be in 'yyyy-mm-dd' format and the starting date for the data is '2001-01-31' for the interest rate API, '1995-09-30' for the balance sheet API, and '1993-04-01' for the debt API. Also please note the balance sheet API is updated every September 30th for the fiscal year. The input for the operator argument are either 'lt' for less than, 'lte' for less than or equal to, 'gt' for greater than, 'gte' for greater than or equal to, and 'eq' for equal to. Also make sure inputs are in quotations and spelled in the same way you can find in this message.")
  
  # Get the url
  finalString <- paste(jsonString, usedEndpoint, limitFilterText, addedText, sep = "")
  
  # Convert to tibble
  jsonData <- httr::GET(finalString)
  
  contents <- jsonlite::fromJSON(rawToChar(jsonData$content))
  
  tibble <- as_tibble(contents$data)
  
  # Return tibble
  return(tibble)
}
```

Now we are going to look at making functions for a specific data set. We really can't filter the debt data in any other way other than by date but we can for the other two. Let us first look at doing this with the [Fed Treasury API on Interest Rates](https://fiscaldata.treasury.gov/datasets/average-interest-rates-treasury-securities/average-interest-rates-on-u-s-treasury-securities).

## `securityType()`

Here we can use our helper function from before to get the security types that are present in the [Fed Treasury API on Interest Rates](https://fiscaldata.treasury.gov/datasets/average-interest-rates-treasury-securities/average-interest-rates-on-u-s-treasury-securities). As we can see they are `r getSecurityList()`. We can use this to get the data we want to analyze by a particular security type. This function has an input of a vector with the type of securities you want to analyze.
```{r security type function}
securityType <- function(vec = NULL){
  # Create Testing List 
  testingList <- getSecurityList()
  # Get text set up
  jsonString <- "https://api.fiscaldata.treasury.gov/services/api/fiscal_service/v2/accounting/od/avg_interest_rates?limit=9999&filter="
  
  addedText <- if (is.null(vec) == TRUE) "" else if(all(vec %in% testingList) == TRUE) paste("security_type_desc:in:(", paste(URLencode(vec), sep = "", collapse = ","), "),", sep = '') else stop("Please input a value that is acceptable. You can find the acceptable values by using the helper function getSecurityList(). Also make sure inputs are in quotations and spelled in the same way you can find in the helper function.")
  
  finalString <- paste(jsonString, addedText, sep = "")
  
  # Convert to tibble
  jsonData <- httr::GET(finalString)
  
  contents <- jsonlite::fromJSON(rawToChar(jsonData$content))
  
  tibble <- as_tibble(contents$data)
  
  # Return tibble
  return(tibble)
}
```

## `individualSecurities()`

Like the `securityType()` function, we might want to instead filter our data by the security itself and not the type (or group of security) in the [Fed Treasury API on Interest Rates](https://fiscaldata.treasury.gov/datasets/average-interest-rates-treasury-securities/average-interest-rates-on-u-s-treasury-securities). Maybe the user is really interested in investing in just Treasury Bonds or maybe the user want to compare just Treasury Bonds to Treasury Notes for interest rates. We can allow the user to do this in a similar manner of how we did it with the `securityType()` function. 
```{r individual security function}
individualSecurities <- function(vec = NULL){
  # Create Testing List 
  testingList <- getSecurityList("specific securities")
  # Get text set up
  jsonString <- "https://api.fiscaldata.treasury.gov/services/api/fiscal_service/v2/accounting/od/avg_interest_rates?limit=9999&filter="
  
  addedText <- if (is.null(vec) == TRUE) "" else if(all(vec %in% testingList) == TRUE) paste("security_desc:in:(", paste(URLencode(vec), sep = "", collapse = ","), "),", sep = '') else stop("Please input a value that is acceptable. You can find the acceptable values by using the helper function getSecurityList('specific securities'). Also make sure inputs are in quotations and spelled in the same way you can find in the helper function.")
  
  finalString <- paste(jsonString, addedText, sep = "")
  
  # Convert to tibble
  jsonData <- httr::GET(finalString)
  
  contents <- jsonlite::fromJSON(rawToChar(jsonData$content))
  
  tibble <- as_tibble(contents$data)
  
  # Return tibble
  return(tibble)
}
```

## `filterPercentage()`

As an investor, we want to target investments that make the most sense with the percentage of interest we would get from that said investment. Users might want to compare rates they found from other stocks and/or bonds with rates that might be offered by the Treasury. The other thing people do is short the market (including bonds). This means they expect rates to go down over time and lock someone into buying an investment at a predetermined rate and then after a certain period of time the seller would have to give the current value of the investment back to the buyer. In this case, the buyer might try to find lower bond interest rates to negotiate the predetermined rate being lower and the seller will want to try to find higher rates to drive the price up. So someone can use this function to try to get data that matches their interest rates goals either from buying a bond to possibly shorting the market. This is used for the [Fed Treasury API on Interest Rates](https://fiscaldata.treasury.gov/datasets/average-interest-rates-treasury-securities/average-interest-rates-on-u-s-treasury-securities).
```{r filter percentages}
filterPercentage <- function(percentage = NULL, operator = NULL){
  # Get text set up
  jsonString <- "https://api.fiscaldata.treasury.gov/services/api/fiscal_service/v2/accounting/od/avg_interest_rates?limit=9999&filter="
  
  addedText <- if ((is.null(operator) == TRUE) | (is.null(percentage) == TRUE)) "" else if(operator %in% c("lt", "gt", "lte", "gte", "eq")) paste("avg_interest_rate_amt:", operator, ":", URLencode(as.character(percentage)), ",", sep = "") else stop("Please input a value that is acceptable. The percentage value must be a float in x.y format where x is a number and so is y to create a float. Numbers should be between 0 and 100 (put 5% as 5 or 5.0). Please do not put the '%' sign after the number. The input for the operator argument are either 'lt' for less than, 'lte' for less than or equal to, 'gt' for greater than, 'gte' for greater than or equal to, and 'eq' for equal to. Also make sure the operator input is in quotations and spelled in the same way you can find in this message.")
  
  finalString <- paste(jsonString, addedText, sep = "")
  
  # Convert to tibble
  jsonData <- httr::GET(finalString)
  
  contents <- jsonlite::fromJSON(rawToChar(jsonData$content))
  
  tibble <- as_tibble(contents$data)
  
  # Return tibble
  return(tibble)
}
```

## `filterBalanceSheet()`

Now we are going to pivot to look at our balance sheet of how we can filter some data out using some key metrics for the [Fed Treasury API on Balance Sheets](https://fiscaldata.treasury.gov/datasets/u-s-government-financial-report/balance-sheets). Please use the the `getAccountTypes()` helper function if you are not sure what the acceptable account types are. This function will be helpful to allow us to look at the balance sheet where we can filter by the account type (asset, liability, etc.) and the specific line items we want. Our last argument in the function is either specified with the word "and" or the word "or" which means if we want the account and line item conditions to match up in with the "and" and the "or" being we want the account type but also the specific line items even if they do not match up.
```{r filter balance sheet}
filterBalanceSheet <- function(account_types = NULL, line_items = NULL, operator = "or"){
  # Get json string for api
  jsonString <- "https://api.fiscaldata.treasury.gov/services/api/fiscal_service/v2/accounting/od/balance_sheets?limit=9999&filter="
  
  # set up acceptable options account types and line items
  acceptableAccountTypes <- getAccountTypes("account")
  acceptableLineItems <- getAccountTypes("line items")
  
  # Get additional added text for account types
  addedText1 <- if(is.null(account_types) == TRUE) "" else if(all(account_types %in% acceptableAccountTypes) == TRUE) paste("account_desc:in:(", paste(URLencode(account_types), sep = "", collapse = ","), "),", sep = '') else stop("Please input a value that is acceptable. You can find the acceptable values by using the helper function getAccountTypes('account'). Also make sure inputs are in quotations and spelled in the same way you can find in the helper function.")
    
  # Get additional added text for line items
  addedText2 <- if(is.null(line_items) == TRUE) "" else if(all(line_items %in% acceptableLineItems) == TRUE) paste("line_item_desc:in:(", paste(URLencode(line_items), sep = "", collapse = ","), "),", sep = '') else stop("Please input a value that is acceptable. You can find the acceptable values by using the helper function getAccountTypes('line items'). Also make sure inputs are in quotations and spelled in the same way you can find in the helper function.")
  
  # Set up condition for "or" being chosen
  if(operator == "or"){
    # Create string urls
    string1 <- paste(jsonString, addedText1, sep = "")
    string2 <- paste(jsonString, addedText2, sep = "")
  
    # Convert to tibble
    jsonData1 <- httr::GET(string1); contents1 <- jsonlite::fromJSON(rawToChar(jsonData1$content)); tibble1 <- as_tibble(contents1$data)
    jsonData2 <- httr::GET(string2); contents2 <- jsonlite::fromJSON(rawToChar(jsonData2$content)); tibble2 <- as_tibble(contents2$data)
    
    # Combine into one tibble and sort repeated values; arrange by date like other data sets; must do if else to get correct tibble printed out based on options selected
    if((is.null(account_types) == TRUE) & (is.null(line_items) == FALSE)){
      final_tibble <- tibble2
    }
    else if((is.null(account_types) == FALSE) & (is.null(line_items) == TRUE)){
      final_tibble <- tibble1
    }
    else{
      final_tibble <- bind_rows(tibble1, tibble2) 
      final_tibble <- final_tibble %>% 
        distinct() %>% 
        arrange(record_date)
    }
  }
  else if(operator == "and"){
    # Combine strings into one to get data
    string <- paste(jsonString, addedText1, addedText2, sep = "")
    
    # Convert to tibble
    jsonData <- httr::GET(string); contents <- jsonlite::fromJSON(rawToChar(jsonData$content)); final_tibble <- as_tibble(contents$data)
  }
  else{
    stop("Must have a valid operator. Options are 'or' and 'and'. The default is 'or'. Please select 'or' if you want the filtering of data to either fall into the category of the accounty type or the line item type. Please select 'and' if you the filtering of data to either fall into the category of the accounty type or the line item type (as is it must be in both conditions).")
  }
  return(final_tibble)
}
```

## `getFunctionNames()`

So we have a lot of functions that all have specific arguments. I wanted to include another function that allows the user to see the functions available, the arguments associated with their default value, and then the corresponding helper function if they are stuck on how to use it. The user can input which data set they want as well to get the functions that correspond to that data set. The data sets we can put in are "balance sheet", "interest rates", and "debt" to look at corresponding helper table of functions.
```{r getting function names}
getFunctionNames <- function(dataset = NULL){
  # Show which dataset options they can be
  dataset_possibilities <- c("interest rates", "debt", "balance sheet")
  
  # Show the names
  names <- c("getUnfilteredData()", "filterDate()", "securityType()", "individualSecurities()", "filterPercentage()", "filterBalanceSheet()")
  
  # Show the arguments
  arguments <- c("data", "data, date, operator", "vec", "vec", "percentage, operator", "account_types, line_items, operator")
  
  # Show default values of functions
  default_values <- c("interest rates", "interest rates, NULL, NULL", "NULL", "NULL", "NULL, NULL", "NULL, NULL, or")
  
  # Show the options user has for values
  value_options <- c("interest rates, debt, balance sheet", "interest rates, debt, balance sheet // date in 'yyyy-mm-dd' format // lt, gt, lte , gte, eq", "look at getSecurityList('security type') for options", "look at getSecurityList('specific securities') for options", "any float between 0 and 100 // lt, gt, lte, gte, eq", "look at getAccountTypes('account') for options // look at getAccountTypes('line items') for options // or, and")
  
  # Show corresponding helper functions users can look at if stuck
  helper_function <- c("NULL", "NULL", "getSecurityList('security type')", "getSecurityList('specific securities')", "NULL", "getAccountTypes('account'), getAccountTypes('line items')")
  
  # Show which datasets are involved in a function
  datasets_involved <- c("interest rates, debt, balance sheet", "interest rates, debt, balance sheet", "interest rates", "interest rates", "interest rates", "balance sheet")
  
  # Make table showing these values
  helper_table <- data.frame(names, arguments, default_values, value_options, helper_function, datasets_involved)
  
  # Return the correct corresponding helper table
  if(is.null(dataset) == TRUE){
    return_tibble <- as_tibble(helper_table)
  }
  else if(all(dataset %in% dataset_possibilities) == TRUE){
    return_tibble <- helper_table %>% 
      filter(str_detect(datasets_involved, paste(dataset[1], dataset[2], dataset[3], sep = "|"))) %>%
      as_tibble()
  }
  else {
    stop("Must put in a dataset value that works. The options are 'interest rates', 'debt', or 'balance sheet'. You may put in more than one value with the c() function. The default value is NULL which returns all the functions from all the data sets.")
  }
  return(return_tibble)
}
```

## `chooseDataset()`

This will be our last function we will have. This is a wrapper function that allows the user to choose which data set they want and the filters they want applied to it. This will make it easier on the user to get data faster rather than trying to surfing for the correct function. In the options for this function, please put the appropriate arguments that would be used in the other corresponding function if used separately.
```{r choose data}
chooseDataset <- function(func, ...){
  if(func == "getUnfilteredData"){
    outputData <- getUnfilteredData(...)
  }
  else if(func == "filterDate"){
    outputData <- filterDate(...)
  }
  else if(func == "securityType"){
    outputData <- securityType(...)
  }
  else if(func == "individualSecurities"){
    outputData <- individualSecurities(...)
  }
  else if(func == "filterPercentage"){
    outputData <- filterPercentage(...)
  }
  else if(func == "filterBalanceSheet"){
    outputData <- filterBalanceSheet(...)
  }
  else{
    stop("Please choose an acceptable named function. The helper file for the list of named function can be found by using the function getFunctionNames(). This will also show you the correct corresponding arguments.")
  }
  
  # Lastly return the data from the corresponding function
  return(outputData)
}
```